---
title: "Estimating varroa recombination rate"
author: "Nurit Eliash"
date: '2022-08-01'
output:
  html_document:
    code_folding: hide
    theme: cerulean
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: yes
      df_print: paged
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style type="text/css">
  body{
  font-size: 12pt;
}
</style>
```
## AIM: Estimate varroa recombintaion rate using whole genome pedigree data

The recombination frequency of *Varroa destructor*, a parasitic mite of honeybees was estimated for male and female adult mites. We used two analysis methods: manual calculation of exact recombination frequency, and computational estimation using a linkage mapping software, Lep-MAP3 (Rastas 2017). For both analyses we used as input a VCF file containing only the ‘Informative sites’. Informative sites are sites that are heterozygotic in the F1 female, and homozygotic for one allele in the F1 male, and his mother (F0 female). Only for these sites we can phase (determine the allele parental origin) the F2 generation genotypes, and follow the inheritance of specific sites through the generations (Fig __).  
All biosamples are available in Sequence Read Archive (SRA) under the accession PRJNA794941.להוסיף לינק!

## load libraries

```{r libraries, echo=TRUE, message=FALSE, warning=FALSE}
library("tidyverse")
library("plyr")
library("dplyr")
library("ggplot2")
library("scales")
library("ggpubr")
library("gridExtra")
library("grid")
library("GGally")
library("vcfR") # for extracting genotype data from a vcf file
library("data.table")
library("stringr")
library("janitor")
knitr::opts_chunk$set(echo = TRUE)
```

## Load Variant Call Format (VCF) file.

Extract genotypes for each site and individual. The metadata for all
samples can be found in
[here](https://github.com/nurit-eliash/varroa-linkage-map/blob/main/data/meta_data_223.xlsx).

```{r}
vcf <- read.vcfR("/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/data/vcf_filter/Q40BIALLDP16HDP40mis.5Chr7/Q40BIALLDP16HDP40mis.5Chr7.recode.vcf", verbose = FALSE )
vcf
# extract the genotype for each site in each individual
gt <- extract.gt(vcf, element = "GT") 
gt <- as.data.frame(t(gt)) %>%
  rownames_to_column("ID")
#clean the ID names
gt$ID <- sub("_[^_]+$", "", gt$ID)
```

# Filter informative sites

These sites will be used as input for the two analyses:  
**(1) Lep-MAP3, a linkage mapping software (Rastas 2017).** In which we
assume all grandchild belong to the same family.  
**(2) Manual estimation of the recombination rate**   

## (1) Estimating recombination frequency using Lep-MAP3
We followed the documentation in the Lep-MAP3 Wiki page (Rastas n.d.), with a few adjustments.  
We ran the first two modules: **ParentCall2**, **Filtering2**, then skipped to the last module **OrderMarkers2** that produces the final map file.  
The input and output files for each modules are as follow:   
(1) **ParentCall2** module; options = removNonInformative; input = filtered VCF file and pedigree.txt; output =  data.call.  
(2) **Filtering2** module; options = dataTolerance=0.0001, removeNonInformative; input = data.call; output =  data_f.call.
(3) **OrderMarkers2** module; options = useKosambi=1 numMergeIterations=100 sexAveraged=1 outputPhasedData=2 grandparentPhase=1; input = data_f.call and map.txt files; output = order.txt and order.mapped files. 

In the following codes we generated two files necessary for the Lep-MAP analysis:  
- the list of informative sites (used to filter the original VCF file), for the first module, **ParentCall2**; 
- and the map.txt file, containing the physical position of sites, for the last module, **OrderMarkers2**.    

**Keep:**

-   Informative sites.  
-   121 adult mite samples.  

**Change:**  

-   Sample ID name (F0, F1_fem, and F1_male)  
-   site genotype for the above 3 samples, as per the cross: 

**For 0/0 x 0/1 cross:**  
    F1_fem = 0/1:22:10,12:10:353:12:444:-33.6837,0,-25.484  
    F1_male = 0/0:17:17,0:17:565:0:0:0,-5.11751,-51.1547  
    F0 = 0/0:17:17,0:17:565:0:0:0,-5.11751,-51.1547

**For 1/1 x 0/1 cross:**  
F1_fem = 0/1:22:10,12:10:353:12:444:-33.6837,0,-25.484  
F1_male = 1/1:17:0,17:0:0:17:629:-56.9466,-5.11751,0  
F0 = 1/1:17:0,17:0:0:17:629:-56.9466,-5.11751,0 

Code for changing sample genotype:
*/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/data/formatVCF.sh*

## (1) Keep informative sites:

filter for informative sites in the original VCF file. 

### cross (0/0 x 0/1) 
in each family, filter for sites with:   
(a) homo x hetero F1 cross (0/0 x 0/1), so we can predict the parental
and recombinant F2 types.  
(b) homo F0 (0/0), so we can phase the hetero F1 sites.  

```{r}
df  <- setNames(data.frame(t(gt[,-1])), gt[,1]) %>% rownames_to_column("site")

# make a vector of all 30 families
families = stringr::str_extract(gt$ID, "[^_]+") %>% unique()

# make an empty list
sites = list()

for (fam in families) {
  sites[[fam]] <- df %>%
    dplyr::select(starts_with(c("site",fam))) %>%
    dplyr::filter_at(vars(matches("_dat")), all_vars(. == "0/1")) %>% 
    dplyr::filter_at(vars(matches("_son")), all_vars(. == "0/0")) %>% 
    dplyr::filter_at(vars(matches("fnd")), all_vars(. == "0/0")) 
}

# make a data frame of all sites from all families
InfoSites_00_01 <- reduce(sites, bind_rows) %>% as.data.frame() %>% select(site) %>% distinct()

InfoSites_00_01 <- separate(InfoSites_00_01, site, into = c("NW","Chr","Pos"), sep = '_') 

InfoSites_00_01$CHR <- paste(InfoSites_00_01$NW, InfoSites_00_01$Chr, sep = "_")
InfoSites_00_01 <- InfoSites_00_01 %>% select(c("CHR", "Pos"))
head(InfoSites_00_01)
```

There are 13,651 informative sites for the 0/0 x 0/1 F1 "family".  
Save the file as tsv, so it can be used in the next steps. 
```{r eval=FALSE, include=T}
write_delim(InfoSites_00_01, "/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/results/InfoSites_00_01.tsv", col_names = FALSE)

# check manually a few IDs and sites,
#InfoSites_00_01 <- reduce(sites, bind_rows) %>% as.data.frame() %>% distinct(site, .keep_all = TRUE)

#tableInfo = InfoSites_00_01 %>% select(c(site,`57_58b_grnson`)) 
#tableAll = df %>% select(c(site,`57_58b_grnson`))
#left_join(tableInfo, tableAll, by = "site") %>% rename(c("57_58b_grnson.x" ="InfoSites", "57_58b_grnson.y" = "AllSites")) %>% view()
```

### cross (1/1 x 0/1)

```{r}
df  <- setNames(data.frame(t(gt[,-1])), gt[,1]) %>% rownames_to_column("site")

# make a vector of all 30 families
families = stringr::str_extract(gt$ID, "[^_]+") %>% unique()

# make an empty list
sites = list()
  
for (fam in families) {
  sites[[fam]] <- df %>%
    dplyr::select(starts_with(c("site",fam))) %>%
    dplyr::filter_at(vars(matches("_dat")), all_vars(. == "0/1")) %>% 
    dplyr::filter_at(vars(matches("_son")), all_vars(. == "1/1")) %>% 
    dplyr::filter_at(vars(matches("fnd")), all_vars(. == "1/1")) 
}

# make a data frame of all sites from all families
InfoSites_11_01 <- reduce(sites, bind_rows) %>% as.data.frame() %>% select(site) %>% distinct()

# make a data frame of all sites from all families
InfoSites_11_01 <- reduce(sites, bind_rows) %>% as.data.frame() %>% select(site) %>% distinct()
InfoSites_11_01 <- separate(InfoSites_11_01, site, into = c("NW","Chr","Pos"), sep = '_') 

InfoSites_11_01$CHR <- paste(InfoSites_11_01$NW, InfoSites_11_01$Chr, sep = "_")
InfoSites_11_01 <- InfoSites_11_01 %>% select(c("CHR", "Pos"))

head(InfoSites_11_01)
```
There are 12,158 informative sites for the 1/1 x 0/1 F1 "family"  
Save the file as tsv, so it can be used in the next steps. 
```{r eval=FALSE, include=T}
write_delim(InfoSites_11_01, "/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/results/InfoSites_11_01.tsv", col_names = FALSE)

# check manually a few IDs and sites,
#InfoSites_11_01 <- reduce(sites, bind_rows) %>% as.data.frame() %>% distinct(site, .keep_all = TRUE)

#tableInfo = InfoSites_11_01 %>% select(c(site,`300_301a_grnson`)) 
#tableAll = df %>% select(c(site,`300_301a_grnson`))
#check <- left_join(tableInfo, tableAll, by = "site") %>% rename(c("300_301a_grnson.x" ="InfoSites", "300_301a_grnson.y" = "AllSites")) %>% na.omit("InfoSites")  

#all(check$InfoSites == check$AllSites)
```

## Next, create a map.txt file with sites' physical position

make a map.txt file with the sites assigned to 7 LGs based on their
physical position use this file as an input for the Order module.

the ordering doesn't have to be fantastic either at the end. We're just
looking to see if we can get some sort of recombination rate estimates
and a sense of which sex is showing recombination.

### cross (0/0 x 0/1)

```{r}
snps <- read_tsv("/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/varroa_lepmap/data/Q40BIALLDP16HDP40mis.5Chr7.infoSites/Q40BIALLDP16HDP40mis.5Chr7.Sites_00_01/snps_611.txt")

CHR = snps$CHR %>% unique()
LG = as.character(c(1:7))
LG_Chr = tibble(LG=as.character(c(1:7)), CHR)

map <- left_join(snps, LG_Chr, by = "CHR") %>% 
  dplyr::select("LG") 

write_delim(map, "/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/varroa_lepmap/data/Q40BIALLDP16HDP40mis.5Chr7.infoSites/Q40BIALLDP16HDP40mis.5Chr7.Sites_00_01/map_611.txt")
```

### cross (1/1 x 0/1)

```{r}
snps <- read_tsv("/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/varroa_lepmap/data/Q40BIALLDP16HDP40mis.5Chr7.infoSites/Q40BIALLDP16HDP40mis.5Chr7.Sites_11_01/snps_202.txt")

CHR = snps$CHR %>% unique()
LG = as.character(c(1:7))
LG_Chr = tibble(LG=as.character(c(1:7)), CHR)

map <- left_join(snps, LG_Chr, by = "CHR") %>% 
  dplyr::select("LG") 

write_delim(map, "/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/varroa_lepmap/data/Q40BIALLDP16HDP40mis.5Chr7.infoSites/Q40BIALLDP16HDP40mis.5Chr7.Sites_11_01/map_202.txt")
```

# check the reduced sites

```{r eval=FALSE, include=FALSE}
#read again the genotype for each site and ID
Gt <- extract.gt(vcf, element = "GT") %>% as.data.frame() %>% rownames_to_column("site")
names(Gt)[-1] <- sub("_[^_]+$", "", names(Gt)[-1])

snps <- read_tsv("/Users/nuriteliash/Documents/GitHub/varroa-linkage-map/varroa_lepmap/data/Q40BIALLDP16HDP40mis.5Chr7.infoSites/Q40BIALLDP16HDP40mis.5Chr7.Sites_00_01/snps_611.txt")

# extract the reduced sites for the gt file
snps$site <- paste(snps$CHR, snps$POS, sep= "_")

#join them by site
tableInfo <- left_join(snps, InfoSites_00_01, by= "site") %>% select(-c("CHR", "POS"))

#table_gt <- left_join(snps, df, by= "site")


dat_info <- InfoSites_00_01 %>% select(c("site", "63_64_dat"))
dat_gt <- Gt %>% select(c("site", "63_64_dat"))
dat_join <- left_join(dat_info, dat_gt, by = "site")

dat_join %>% filter(`63_64_dat.y` == "0/0")
dat_join %>% filter(`63_64_dat.x` == "0/0")

dat_join %>% filter(`63_64_dat.y` == "1/1") %>% view()
dat_join %>% filter(`63_64_dat.x` == "1/1") %>% view()
```






לעשות את זה אחר כך :
לעבוד על החלק של החישוב הידני בנפרד







------------------------------------------------------------------------

## For all families (pooled data)

Count the sites with each genotype in each family, per chromosome.\
The counts must be per chromosome, as recombination can occur only
between sites on the same chromosome.

```{r}
table <- gt %>% 
  t() %>%
  as.data.frame() %>%
  row_to_names(row_number = 1)
 # dplyr::select(contains(c("son", "dat", "fnd"))) # keep only adults of F0, F1 and F2 

# set chromosome variable 
chromosomes = c("NW_019211454.1","NW_019211455.1","NW_019211456.1", "NW_019211457.1","NW_019211458.1","NW_019211459.1","NW_019211460.1")
  
# define a list to put all the data frames in
chr_list <- list()

# make a list with dataframes - each containing 1 chromosome
for (chr in chromosomes) {
  chr_list[[chr]] <- table %>%
  rownames_to_column("site") %>%
  dplyr::filter(stringr::str_detect(site,chr)) 
      }

# set a vector of all 30 families:
family = str_extract(gt$ID, "[^_]+") %>% unique()

# or, include only families with at least one adult F2
#family = grep("grndat|grnson",gt$ID, value=TRUE) %>%
#  str_extract("[^_]+")  %>%
#  unique()

# make a function to apply:
fun <- function(df) {
  df %>%
  dplyr::select(starts_with(fam)) %>%
  dplyr::filter_at(vars(matches("_son")), all_vars(. == "0/0")) %>%
  dplyr::filter_at(vars(matches("_dat")), all_vars(. == "0/1")) %>% 
  dplyr::filter_at(vars(matches("_fnd")), all_vars(. == "0/0")) %>%
  dplyr::select(contains("grn")) %>% 
  tidyr::pivot_longer(everything())  %>% 
  dplyr::rename(sample = name, gt = value) %>%
  dplyr::count(sample, gt, .drop = FALSE) %>% 
  dplyr::filter(gt %in% c("0/0", "1/1", "0/1")) %>%
  mutate(n = as.numeric(n)) %>%
  group_by(sample) %>%
  mutate(total = as.numeric(sum(n))) %>%
  dplyr::rename(obs = n) %>%
  mutate(sex = case_when(
    grepl("son", sample) ~ "male",
    grepl("dat", sample) ~ "female"))
    }

# make an empty list
obs <- list() 

# apply the function for each of the chromosome, per family 
for (fam in family) {
 obs[[fam]] <- lapply(chr_list, fun)
}

# bind all families together, to a final data frame containing all observed counts
#observed <- do.call("rbind", obs)
```

visualize the sites, for one family (240), on the first chromosome
(NW_019211454.1):

```{r}
table %>%
  rownames_to_column("site") %>%
  dplyr::filter(stringr::str_detect(site,"NW_019211454.1")) %>%
    dplyr::select(starts_with(c("site", "240"))) %>%
    dplyr::filter_at(vars(matches("_son")), all_vars(. == "0/0")) %>%
    dplyr::filter_at(vars(matches("_dat")), all_vars(. == "0/1")) %>%  
  dplyr::filter_at(vars(matches("_fnd")), all_vars(. == "0/0")) %>% view()

```

Next, calculate the recombination frequency, that is, the number of
sites pairs, that are recombinant among the all possible pairs in each
chromosome.\
we do that by determining the 'recombinant' and 'parental' types of
sites combinations, for males (parthenogenetically produced) and females
(sexually produced) separately.\
For the 0/0 x 0/1 cross, in both males and females F2, parental type
will have the same genotype in a pair of sites, while a recombinant type
will have different genotype in a pair:\
**F2 females:**. \* Parental types: 0/1;0/1 and 0/0;0/0\
\* Recombinant types: 0/1;0/0

**F2 males:**. \* Parental types: 0/1;0/1 , 0/0;0/0 and 1/1;1/1 \*
Recombinant types: 0/1;0/0, 0/1;1/1 and 1/1;0/0 (depends on the type of
parthenogenesis)

so all we need to do in order to count recombination events in a
chromosome, is to count the pairs of **same** and **different**
genotypes, and divide by the length of the chromosome.

-   Calculations:\
    **Sum of unique pairs** = *n(n-1)/2 x n* = number of genotyped sites
    (example\$total).\
    **Male recombinant pairs** = *count of 0/1 sites x count of 0/0+1/1
    sites*.\
    **Female recombinant pairs** = *count of 0/1 sites x count of 0/0
    sites*.\
    **Recombination frequency** = *recombinant pairs / sum of unique
    pairs*.\
    **Normalized recombination freq** = *freq/chromosome length (bp)*.

```{r eval=FALSE, include=FALSE}
chr_length = tibble(Chr = c("NW_019211454.1", "NW_019211455.1", "NW_019211456.1", "NW_019211457.1", "NW_019211458.1", "NW_019211459.1", "NW_019211460.1"),
             bp = c(76960006, 60513814,58583513,52932055,42024542,32556157,39431147))

# calculate recombination freq for each male and female sample
example <- as.data.frame(obs$`133`$NW_019211457.1) %>% 
  mutate(sum_pairs = total*(total-1)/2) %>%
  mutate(Chr = "NW_019211457.1") %>%
  left_join(chr_length, by = "Chr") %>%
  mutate(sex = replace_na(sex, "female")) %>% # assume all F2 nymphs are females
  mutate(fam = str_extract(sample, "[^_]+")) %>%
  pivot_wider(names_from = gt, values_from = obs) %>%
  mutate(recomb_pairs = case_when(sex == "female" ~ `0/0` * `0/1`, 
                                  sex == "male" ~ (`0/0`+`1/1`) * `0/1`)) %>%
  mutate(freq = recomb_pairs/sum_pairs) %>%
  mutate(freq_cM_bp = freq/bp)

# same
example <- 
  obs[[fam]][[chr]] %>% as.data.frame() %>% 
  mutate(sum_pairs = total*(total-1)/2) %>%
  mutate(Chr = chr) %>%
  left_join(chr_length, by = "Chr") %>%
  mutate(sex = replace_na(sex, "female")) %>% # assume all F2 nymphs are females
  mutate(fam = str_extract(sample, "[^_]+")) %>%
  pivot_wider(names_from = gt, values_from = obs) %>%
  mutate(recomb_pairs = case_when(sex == "female" ~ `0/0` * `0/1`, 
                                  sex == "male" ~ (`0/0`+`1/1`) * `0/1`)) %>%
  mutate(freq = recomb_pairs/sum_pairs) %>%
  mutate(freq_cM_bp = freq/bp) %>% view()


# make a function to loop over all families, is each chromosome
func_recom <- function(df) {
  df %>%
  as.data.frame() %>%
  mutate(sum_pairs = total*(total-1)/2) %>%
  mutate(Chr = chr) %>%
  left_join(chr_length, by = "Chr") %>%
  mutate(sex = replace_na(sex, "female")) %>% # assume all F2 nymphs are females
  mutate(fam = str_extract(sample, "[^_]+")) %>%
  pivot_wider(names_from = gt, values_from = obs) %>%
  mutate(recomb_pairs = case_when(sex == "female" ~ `0/0` * `0/1`, 
                                  sex == "male" ~ (`0/0`+`1/1`) * `0/1`)) %>%
  mutate(freq = recomb_pairs/sum_pairs) %>%
  mutate(freq_cM_bp = freq/bp)
}

recomb_freq <- list()

# apply the function for each element in the large list (list of lists) of the chromosome, per family 
for (chr in chromosomes) {
  for (fam in family) {
 recomb_freq[[chr]][[fam]] <- func_recom(obs[[fam]][[chr]]) } }

# bind all element into one data frame
obs_df <- data_frame()
obs_dfAll <- data_frame()

for (chr in chromosomes) {
  obs_df <- bind_rows(recomb_freq [[chr]])
  obs_dfAll <- rbind(obs_df, obs_dfAll)}

# plot the median of recombination freq, per chromosome
ggplot(obs_dfAll, aes(x=Chr, y=freq, fill=sex)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free")

ggplot(obs_dfAll, aes(x=Chr, y=freq_cM_bp, fill=sex)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free")

# filter out families with low number of sites
ggplot(filter(obs_dfAll, total > 10), aes(x=Chr, y=freq_cM_bp, fill=sex)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free")

# by sex:
p_byFamily_male <- ggplot(filter(obs_dfAll, sex == "male" & total > 10), aes(x=fam, y=freq)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free")

p_byFamily_fem <- ggplot(filter(obs_dfAll, sex == "female" & total > 10), aes(x=fam, y=freq)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free") 

p_byFamily_fem_freq_cM_bp <- ggplot(filter(obs_dfAll, sex == "female" & total > 10), aes(x=fam, y=freq_cM_bp)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free") 

p_byFamily_male_freq_cM_bp <- ggplot(filter(obs_dfAll, sex == "male" & total > 10), aes(x=fam, y=freq_cM_bp)) + 
    geom_boxplot() +
    facet_wrap(~Chr, scale="free") 
```
